from flask import Flask, render_template, request, flash, redirect, send_file
from flask_mail import Mail, Message
import cohere
import json
import time
import os
import smtplib
from dotenv import load_dotenv
from io import BytesIO
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from reportlab.pdfbase.pdfmetrics import stringWidth

# Load environment variables
load_dotenv()

# Initialize Flask app
app = Flask(__name__)
app.secret_key = os.getenv('SECRET_KEY', 'your-secret-key-here')

# Configure Flask-Mail
app.config.update(
    MAIL_SERVER=os.getenv('MAIL_SERVER', 'smtp.gmail.com'),
    MAIL_PORT=int(os.getenv('MAIL_PORT', 587)),
    MAIL_USE_TLS=os.getenv('MAIL_USE_TLS', 'True') == 'True',
    MAIL_USE_SSL=os.getenv('MAIL_USE_SSL', 'False') == 'True',
    MAIL_USERNAME=os.getenv('MAIL_USERNAME'),
    MAIL_PASSWORD=os.getenv('MAIL_PASSWORD'),
    MAIL_DEFAULT_SENDER=os.getenv('MAIL_DEFAULT_SENDER'),
    MAIL_TIMEOUT=30,
    MAIL_DEBUG=True
)

mail = Mail(app)

# Initialize Cohere client
COHERE_API_KEY = os.getenv('COHERE_API_KEY', 'your-cohere-key')
co = cohere.Client(COHERE_API_KEY)

# Load prompt templates
with open("prompts.json") as f:
    prompt_templates = json.load(f)

# In-memory store for dashboard
saved_copies = []

# Helper: Split text for wrapping
def split_text(text, max_width, canvas_obj, font_name="Helvetica", font_size=12):
    words = text.split()
    lines = []
    current_line = ""
    for word in words:
        test_line = f"{current_line} {word}".strip()
        if stringWidth(test_line, font_name, font_size) <= max_width:
            current_line = test_line
        else:
            lines.append(current_line)
            current_line = word
    if current_line:
        lines.append(current_line)
    return lines

# Helper: Draw header and footer
def draw_header_footer(canvas_obj, width, height, page_num):
    canvas_obj.setFont("Helvetica-Bold", 14)
    canvas_obj.drawString(50, height - 30, "Marketing Copy Generator")

    canvas_obj.setFont("Helvetica-Oblique", 10)
    canvas_obj.drawString(50, 20, f"Page {page_num}")
    canvas_obj.drawRightString(width - 50, 20, "Generated by AI · © 2025")

# Route: Homepage
@app.route("/", methods=["GET", "POST"])
def index():
    result = ""
    token_usage = {"prompt_tokens": 0, "generation_tokens": 0, "total_tokens": 0}
    form_data = None

    if request.method == "POST":
        start_time = time.time()

        form_data = {
            "prompt_type": request.form.get("prompt_type"),
            "tone": request.form.get("tone"),
            "product": request.form.get("product"),
            "audience": request.form.get("audience"),
            "extra": request.form.get("extra"),
            "email": request.form.get("email")
        }

        prompt_template = prompt_templates.get(form_data["prompt_type"], "")
        prompt = prompt_template.format(**form_data)

        try:
            response = co.generate(
                model="command",
                prompt=prompt,
                max_tokens=150,
                temperature=0.7
            )
            result = response.generations[0].text.strip()

            if hasattr(response, "meta") and response.meta and hasattr(response.meta, "tokens"):
                token_usage = {
                    "prompt_tokens": getattr(response.meta.tokens, "prompt_tokens", 0),
                    "generation_tokens": getattr(response.meta.tokens, "generated_tokens", 0),
                    "total_tokens": getattr(response.meta.tokens, "total_tokens", 0)
                }

            if form_data["email"]:
                try:
                    send_email(form_data["email"], form_data["prompt_type"], result)
                    flash("Your generated copy has been sent to your email!", "success")
                except Exception as e:
                    flash(f"Error sending email: {str(e)}", "danger")

        except Exception as e:
            result = f"Error: {str(e)}"
            flash(result, "danger")

        elapsed = round(time.time() - start_time, 2)
        return render_template(
            "index.html",
            result=result,
            time=elapsed,
            token_usage=token_usage,
            form_data=form_data,
            saved_copies=saved_copies
        )

    return render_template("index.html", result=None, form_data=None, token_usage=None, saved_copies=saved_copies)

# Route: Save copy to dashboard
@app.route("/save_copy", methods=["POST"])
def save_copy():
    content = request.form.get("content")
    prompt_type = request.form.get("prompt_type")
    tone = request.form.get("tone")

    if content and prompt_type:
        saved_copies.append({
            "content": content,
            "prompt_type": prompt_type,
            "tone": tone
        })
        flash("Copy saved to dashboard!", "success")
    else:
        flash("Missing data to save copy.", "danger")

    return redirect("/")

# Route: PDF Download
@app.route("/download", methods=["POST"])
def download_pdf():
    content = request.form.get("content")
    if not content:
        flash("No content to generate PDF.", "danger")
        return redirect("/")

    buffer = BytesIO()
    pdf = canvas.Canvas(buffer, pagesize=letter)
    width, height = letter
    margin = 50
    max_width = width - 2 * margin
    y = height - margin - 20
    page_num = 1

    text_object = pdf.beginText(margin, y)
    text_object.setFont("Helvetica", 12)

    for paragraph in content.split('\n'):
        lines = split_text(paragraph, max_width, pdf)
        for line in lines:
            if y < 70:
                pdf.drawText(text_object)
                draw_header_footer(pdf, width, height, page_num)
                pdf.showPage()
                page_num += 1
                y = height - margin - 20
                text_object = pdf.beginText(margin, y)
                text_object.setFont("Helvetica", 12)
            text_object.textLine(line)
            y -= 15

    pdf.drawText(text_object)
    draw_header_footer(pdf, width, height, page_num)
    pdf.save()
    buffer.seek(0)

    return send_file(
        buffer,
        as_attachment=True,
        download_name="marketing_copy.pdf",
        mimetype="application/pdf"
    )

# Helper: Send email
def send_email(to_email, prompt_type, content):
    subject = f"Your Generated {prompt_type.replace('_', ' ').title()}"
    body = f"""Here's the marketing copy you requested:\n\n{content}\n\n---\nGenerated by Marketing Copy Generator"""

    try:
        msg = Message(subject=subject, recipients=[to_email], body=body)
        with mail.connect() as connection:
            connection.send(msg)
    except smtplib.SMTPException as e:
        raise Exception(f"SMTP Error: {str(e)}")
    except Exception as e:
        raise Exception(f"Email failed: {str(e)}")

# Optional: Test email configuration
def test_email_config():
    with app.app_context():
        try:
            print("Testing email configuration...")
            with mail.connect() as connection:
                msg = Message(
                    subject="Test Email from Marketing Generator",
                    recipients=["test@example.com"],
                    body="This is a test email to verify configuration."
                )
                connection.send(msg)
            print("✓ Email configuration is working!")
            return True
        except Exception as e:
            print(f"✗ Email configuration failed: {e}")
            return False

# Run app
if __name__ == "__main__":
    if test_email_config():
        port = int(os.environ.get("PORT", 5000))
        app.run(host="0.0.0.0", port=port)
    else:
        print("Server not started due to email configuration issues.")
